NOTE :
- Les expressions qui tiennent lieu de citations seront écrites entre guillemets : «».
- Les expressions qui tiennent lieu de code(ou semi-code) seront écrites entre double guillemets : ««»».
- Les chaînes de caractères contenu dans les codes(ou semi-codes) seront écrites entre double côtes : "".


    Salut. C'est moi, Samuel. Je parlerai du programme Calculatrice que j'ai écris dernièrement. Allons y!
    Tout a commencé avec l'idée de faire un projet en C ou C++. J'ai fais quelques recherches sur Internet pour trouver des projets. J'ai pu avoir plusieurs propositions mais j'ai lu des commentaires dans lesquels des gens parlaient de calculatrice. Cela a attiré mon attention. J'avais créé de programme pour faire des calculs par le passé mais c'était que des choses basiques; c'est-à-dire le genre de programme qui te demande d'entrer deux nombres et de choisir l'opération à effectuer. Je me suis alors décidé à écrire un programme de calculatrice plus ou moins complet. Avec ce programme, l'utilisateur devrait être en mesure d'entrer sous forme textuelle les opérations qu'il veut effectuer. Par exemple s'il écrit ««"2+3×4"»», le programme va lui retouner ««14»».
    
    SECTION 1 : LES FONCTIONS BASIQUES
    Pour commencer, j'ai choisi de créer le programme en utilisant le langage C. Pour faire simple, je me suis référé à une application Calculatrice que j'avais sur mon smartphone, pour me décider des fonctionnalités que fournira mon programme.
    Au début j'ai eu l'idée de créer des fonctions pour chacunes des opérations possibles et une autre pour «opérer». J'ai donc créé des fonctions pour l'addition, la soustraction, la multiplication, la division, le pourcentage et la factorielle. Je n'ai pas créé de fonctions pour le sinus, le cosinus, l'arc sinus, etc parce que ces fonctions sont fournies de façon standard par le langage C. En ce qui concerne la fonction qui permet d'«opérer», on peut la considérer comme une fonction qui permet seulement d'appeler d'autres fonctions. Noter que toute ces fonctions doivent retouner des nombres réels. Pour avoir une précision maximale, j'ai choisir d'utiliser le type ««long double»» pour les paramètres ainsi que pour les valeurs de retours. Noter aussi que toutes ces fonctions sont considérés comme étant des ««fonctions internes»» au sein du programme.
    J'ai décidé que pour effectuer les calculs, le programme devrait passer par une étape ou chaque opération à effectuer serait écrite textuellement. Par exemple pour calculer ««2+3×4»» on doit d'abord effectuer une conversion qui nous permettra d'obtenir : ««"add(2,multiply(3,4))"»». Jusqu'à là je ne savais pas comment effectuer une telle conversion mais je savais qu'on aura besoin de tenir compte de la priorité des opérateurs.
    La fonction ««operate(...)»» devrait prendre un paramètre de type chaîne de caractères comme ««"add(2,multiply(3,4))"»». A partir de ce genre de paramètre, elle devrait identifier la fonction à exécuter ainsi que ces paramètres. Il me fallait donc une fonction qui puisse analyser une chaîne de caractères pour identifier l'opération que cette dernière indique ainsi que le/les arguments(il ne faut pas oublier que les fonctions prennent un ou deux arguments). J'ai donc créé la fonction  ««getFunctionInfos(...)»» qui prend en paramètre une chaîne de caractères et retourne un objet de structure contenant les informations recherchées.
    Par exemple si le paramètre est ««"add(2,3)"»», la fonction ««operate(...)»» doit appeler la fonction d'addition et lui transmettre les paramètres 2 et 3. Par exemple si le paramètre est ««"add(2,multiply(3,4))"»», la fonction ««operate(...)»» doit appeler la fonction d'addition et lui transmettre deux paramètres. Le premier paramètre est 2 et le second est la valeur de retour de la fonction de multiplication appliquée aux valeurs 3 et 4. On comprend donc que la fonction ««operate(...)»» doit pouvoir s'appeler de façon récursive. Ainsi, ««operate("add(2,3)")»» va conduire à ««add(operate("2"),operate("3"))»». De même ««operate("add(2,multiply(3,4))")»» doit conduire à ««add(operate("2"),operate("multiply(3,4)"))»» puis ««add(operate("2"),multiply(operate("3"),operate("4")))»». Il faut noter a ce niveau que en tant normal la chaîne de caractères fournie à la fonction ««operate(...)»» doit indiquer la fonction à appeler. Mais un peu plus haut, j'ai écrit des choses comme «operate("2")». Cela est bien évidemment erroné. C'est à cause de ça que j'ai créé la fonction interne ««toDecimal(...)»» qui contrairement aux autres fonctions internes prend en paramètre une chaîne de caractères. Elle retourne un ««long double»» correspondant au paramètre qu'elle reçoit. Ainsi, pour calculer ««2+3×4»» on doit d'abord effectuer une conversion qui nous permettra d'obtenir : ««"add(toDecimal(2),multiply(toDecimal(3),toDecimal(4)))"»» et non pas ««"add(2,multiply(3,4))"»».
    Enfin, si le programme doit effectuer un long calcul, la fonction ««operate(...)»» se retrouverait à manipuler de longues chaînes de caractères. Vu que certaines fonctions ont un nom plus tôt long et aussi pour des raisons de maintenance, j'ai décidé d'utiliser des définitions symboliques pour toutes les fonctions internes. De plus pour intercepter les erreurs du type «Infinity» et «Not A Number», j'ai créé une fonction supplémentaire nommée «detectNanInfErrors».
    
    SECTION 2 : L'UTILISATION DE LISTES
    Jusqu'ici, je parviens à faire des calculs en fournissant une chaîne de caractères suivant une syntaxe bien rigoureuse. Mais la manipulation des chaînes de caractères n'est pas très intuitive. C'est pour ça que j'ai décidé de faire appel aux listes. L'idée est de pouvoir représenter les opérations mathématiques sous la forme d'une liste chaînée dont les éléments seront des «objets d'opération». J'ai alors décidé de créer une structure pour des listes doublement chaînées et j'ai écrit diverses fonctions permettant de manipuler correctement ces listes. Je peux désormais facilement insérer ou supprimer un objet d'opération.

    SECTION 3 : LES ARBRES
    La fonction ««operate(...)»» ne prend que des chaînes de caractères qui laissent apparaître de manière explicite l'ordre des opérations. Mais dans la vraie vie, il sera fréquent que l'utilisateur entre une opération pas assez explicite au point qu’il nous reviendrait de déterminer l'ordre des opérations. Et pour déterminer cet ordre nous nous baserons sur deux concepts : les blocs d'opération et les opérateurs. En effet toute opération peut être vue sous la forme d'une combinaison de blocs d'opération et d'opérateurs. Nous considérons qu'un bloc est soit une suite d'opérations encadrées par deux parenthèses (par exemple ««"(2+4/6)"»»), ou un appel de fonction (par exemple ««"sin(10)"»» ou  ««"ln(10-20)"»»), ou (dans sa forme la plus simple) juste un nombre. Ainsi dans l'expression ««"2-(4*3)+cos(36)"»» nous avons à première vue trois blocs et deux opérateurs. C'est en allant un peu plus en profondeur qu'on pourra dire qu'on a trois sous-blocs (««"4"»», ««"3"»» et ««"36"»»). De cette façon on peut structurer n'importe quelle opération mathématique sous la forme d'une hiérarchie de blocs et d'opérateurs : un arbre. C'est pour ces raisons que j'ai créé une structure pour représenter les arbres dans le programme et j'ai également écrit des fonctions pour manipuler ces arbres.

    SECTION 4 : LES FONCTIONS ««manage...»»
    J'ai désormais la possibilité d'utiliser un arbre pour savoir comment les opérations seront imbriquées les unes dans les autres. Mais je n'ai pas encore géré un détail : comment transformer une liste contenant ««"2+3"»» en une liste contenant ««"ad(td(2),td(3))"»» ? Pour y arriver, j'ai créé les fonctions ««manage...»» (««manageConstant(...)»», ««manageNumber(...)»», ««manageOperator(...)»», ««manageExternalFunction(...)»» et ««manageAdditionalParentheses(...)»») qui permettent de convertir le contenu d'une liste provenant d'une saisie utilisateur en une liste utilisant les fonctions internes et dont le contenu correspond aux attentes de la fonction ««operate(...)»».

    SECTION 5 : TRANSFORMER UNE OPÉRATION SAISIE PAR L'UTILISATEUR EN QUELQUE CHOSE DE CALCULABLE EN UTILISANT LES LISTES ET ARBRES
    Désormais, je sais hiérarchiser les opérations et je sais traiter les opérateurs mais je ne sais pas encore comment décider l'ordre dans lequel les opérateurs d'un même bloc seront évalués. C'est pour ça que j'ai créé la fonction ««sortOperators(...)»» qui permet de trier une liste d'opérateurs selon les ordres de priorité. Ensuite j'ai créé la fonction ««manageBlockOperators(...)»» pour trier et traiter tous les opérateurs d'un bloc d'opérations. Puis j'ai créé la fonction ««manageAllObjects(...)»» qui permet de traiter tous les éléments constitutifs d'une opération. Désormais, si j'ai une opération bien formulée par l'utilisateur, je peux la convertir en une chaîne de caractères d'opération valide à transmettre à la fonction ««operate(...)»». Mais l'utilisateur ne pourra pas toujours faire une saisie valide. On aura donc besoin que notre calculatrice analyse la syntaxe des opérations entrées. Et c'est uniquement si l'utilisateur entre une opération correcte qu'on l'exécutera sinon on signalera l'erreur.

    SECTION 6 : VALIDATION DE LA SYNTAXE DES OPÉRATIONS SAISIES PAR L'UTILISATEUR
    Pour y arriver, j'ai d'abord créé une fonction ««stringToList(...)»» qui permet de convertir une chaîne de caractères en liste. L'idée est d'analyser la chaîne de caractères et d'identifier les objets d'opérations qui la constituent; ensuite ces objets sont réunis pour former une liste. Par la suite j'ai créé diverses fonctions pour permettre d'analyser la syntaxe d'une opération. Veuillez lire le fichier «Les règles syntaxique» pour mieux comprendre les règles syntaxiques et par conséquent comment je les ai appliquées dans le code. J'ai également ajouté les fonctions ««manageAllConstants(...)»» et ««manageImplicitMultiplications(...)»» qui permettent de gérer quelques détails avant que la liste (contenant les opérations) ne soit utilisée dans le reste du programme. Le programme est désormais prêt pour permettre d'effectuer les calculs. Mais j'ai décidé de lui construire une bonne interface utilisateur (en ligne de commande).

    SECTION 7 : INTERFACE EN LIGNE DE COMMANDE ET OUTILS SUPPLÉMENTAIRES
    Pour que le programme soit facile à utiliser, j'ai créé plusieurs fonctions supplémentaires (comme ««isCommand(...)»» ou ««c_setPrecision(...)»») et j'ai écrit le code nécessaire pour fournir une bonne interface à l'utilisateur. A cette étape, j'ai réfléchi à la possibilité de faire en sorte qu'on puisse étendre la calculatrice avec des outils. Pour le moment j'ai ajouté un seul outil qui permet de vérifier si un nombre est premier ou non.
    