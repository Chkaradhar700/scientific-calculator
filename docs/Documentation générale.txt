NOTE

- Les expressions qui tiennent lieu de citations seront écrites entre guillemets : « ».
- Les expressions qui tiennent lieu de code (ou semi-code) seront écrites entre double guillemets : «« »».
- Les chaînes de caractères contenues dans les codes (ou semi-codes) seront écrites entre double quotes : "".


INTRODUCTION

Ce document présente le programme Calculatrice, que j’ai écrit en 2023.

Tout a commencé avec l’idée de réaliser un projet en C ou en C++. J’ai fait quelques recherches sur Internet afin de trouver des idées de projets. Parmi les propositions rencontrées, certaines personnes parlaient de calculatrice, ce qui a attiré mon attention.

J’avais déjà créé des programmes de calcul par le passé, mais il s’agissait uniquement de choses basiques, comme des programmes demandant à l’utilisateur d’entrer deux nombres puis de choisir une opération à effectuer. J’ai alors décidé d’écrire un programme de calculatrice plus complet. Avec ce programme, l’utilisateur devrait être en mesure d’entrer, sous forme textuelle, les opérations qu’il souhaite effectuer.

Par exemple, s’il écrit ««"2+3×4"»», le programme doit être capable de lui retourner ««14»».


SECTION 1 : LES FONCTIONS BASIQUES

Pour commencer, j’ai choisi de créer le programme en utilisant le langage C. Afin de définir les fonctionnalités de base, je me suis référé à une application de calculatrice présente sur mon smartphone.

Au départ, j’ai eu l’idée de créer une fonction pour chacune des opérations possibles, ainsi qu’une autre fonction chargée d’« opérer ». J’ai donc créé des fonctions pour l’addition, la soustraction, la multiplication, la division, le pourcentage et la factorielle. Je n’ai pas créé de fonctions pour le sinus, le cosinus, l’arc sinus, etc., car ces fonctions sont fournies par la bibliothèque mathématique standard du langage C (math.h).

La fonction qui permet d’« opérer » peut être considérée comme une fonction qui se contente d’appeler les autres fonctions. À ce niveau, il est important de noter que toutes ces fonctions doivent retourner des nombres réels. Afin d’obtenir une précision maximale, j’ai choisi d’utiliser le type ««long double»» pour les paramètres ainsi que pour les valeurs de retour. Pour que ces fonctions mathématiques soient correctement liées lors de la compilation, le programme est compilé en utilisant l’option «-lm» de gcc. Toutes ces fonctions sont considérées comme des ««fonctions internes»» du programme.

J’ai ensuite décidé que, pour effectuer les calculs, le programme devait passer par une étape intermédiaire durant laquelle chaque opération à effectuer serait écrite sous forme textuelle. Par exemple, pour calculer ««2+3×4»», il faut d’abord effectuer une conversion permettant d’obtenir : ««"add(2,multiply(3,4))"»». À ce stade, je ne savais pas encore comment effectuer une telle conversion, mais je savais qu’il faudrait tenir compte de la priorité des opérateurs.

La fonction ««operate(...)»» devait donc prendre en paramètre une chaîne de caractères telle que ««"add(2,multiply(3,4))"»». À partir de ce paramètre, elle devait identifier la fonction à exécuter ainsi que ses paramètres. Il me fallait alors une fonction capable d’analyser une chaîne de caractères afin d’identifier l’opération indiquée ainsi que ses arguments. J’ai donc créé la fonction ««getFunctionInfos(...)»», qui prend en paramètre une chaîne de caractères et retourne un objet de structure contenant ces informations.

Par exemple, si le paramètre est ««"add(2,3)"»», la fonction ««operate(...)»» doit appeler la fonction d’addition et lui transmettre les paramètres 2 et 3. Si le paramètre est ««"add(2,multiply(3,4))"»», la fonction ««operate(...)»» doit appeler la fonction d’addition et lui transmettre deux paramètres : le premier est 2, et le second est la valeur de retour de la fonction de multiplication appliquée aux valeurs 3 et 4.

On comprend donc que la fonction ««operate(...)»» doit pouvoir s’appeler de manière récursive. Ainsi, ««operate("add(2,3)")»» conduit à ««add(operate("2"),operate("3"))»». De même, ««operate("add(2,multiply(3,4))")»» conduit successivement à ««add(operate("2"),operate("multiply(3,4)"))»» puis à ««add(operate("2"),multiply(operate("3"),operate("4")))»».

À ce niveau, il faut noter qu’en temps normal, la chaîne de caractères fournie à la fonction ««operate(...)»» doit indiquer explicitement la fonction à appeler. Les appels du type «operate("2")» sont donc incorrects. C’est pour cette raison que j’ai créé la fonction interne ««toDecimal(...)»». Contrairement aux autres fonctions internes, elle prend en paramètre une chaîne de caractères et retourne un ««long double»» correspondant à la valeur numérique représentée par cette chaîne. Cette fonction est utilisée uniquement pour convertir des valeurs littérales (des nombres écrits sous forme textuelle) en nombres réels.

Ainsi, pour calculer ««2+3×4»», on doit d’abord effectuer une conversion permettant d’obtenir :
««"add(toDecimal(2),multiply(toDecimal(3),toDecimal(4)))"»»
et non pas ««"add(2,multiply(3,4))"»».

Enfin, si le programme doit effectuer un calcul long, la fonction ««operate(...)»» peut être amenée à manipuler de longues chaînes de caractères. Étant donné que certaines fonctions internes ont des noms relativement longs et pour des raisons de maintenance, j’ai décidé d’utiliser des définitions symboliques pour représenter toutes les fonctions internes. De plus, afin d’intercepter les erreurs de type «Infinity» et «Not A Number», j’ai créé une fonction supplémentaire nommée «detectNanInfErrors».


SECTION 2 : L’UTILISATION DE LISTES

Jusqu’ici, je parviens à effectuer des calculs en fournissant une chaîne de caractères respectant une syntaxe bien définie. Toutefois, la manipulation directe des chaînes de caractères n’est pas très intuitive. C’est pour cette raison que j’ai décidé de faire appel aux listes.

L’idée est de représenter les opérations mathématiques sous la forme d’une liste chaînée dont les éléments sont des objets d’opération. J’ai donc créé une structure pour des listes doublement chaînées, ainsi que diverses fonctions permettant de les manipuler correctement. Il est désormais possible d’insérer ou de supprimer facilement un objet d’opération.

Les listes sont utilisées à plusieurs étapes du programme, notamment pour représenter les opérations, faciliter leur transformation progressive et permettre des insertions et suppressions d’objets d’opération à différents moments du traitement.


SECTION 3 : LES ARBRES

La fonction ««operate(...)»» ne prend en paramètre que des chaînes de caractères dans lesquelles l’ordre des opérations est explicitement défini. Or, dans la pratique, il est fréquent que l’utilisateur entre une opération dont l’ordre n’est pas suffisamment explicite. Il revient alors au programme de déterminer cet ordre en se basant sur les règles de priorité.

Pour cela, je me suis appuyé sur deux concepts : les blocs d’opération et les opérateurs. Une opération mathématique peut être vue comme une combinaison de blocs d’opération et d’opérateurs. Un bloc est soit une suite d’opérations encadrée par des parenthèses (par exemple ««"(2+4/6)"»»), soit un appel de fonction (comme ««"sin(10)"»» ou ««"ln(10-20)"»»), soit, dans sa forme la plus simple, un nombre.

Par exemple, dans l’expression ««"2-(4*3)+cos(36)"»», on identifie à première vue trois blocs et deux opérateurs. En analysant plus en profondeur, on obtient également des sous-blocs (««"4"»», ««"3"»» et ««"36"»»). De cette manière, toute opération mathématique peut être structurée sous la forme d’une hiérarchie de blocs et d’opérateurs, c’est-à-dire un arbre.

Chaque nœud de l’arbre représente un bloc d’opération, auquel sont joints les opérateurs qu’il contient. C’est pour ces raisons que j’ai créé une structure permettant de représenter les arbres dans le programme, ainsi que les fonctions nécessaires à leur manipulation.


SECTION 4 : LES FONCTIONS ««manage...»»

Grâce à l’utilisation des arbres, je suis désormais capable de déterminer comment les opérations sont imbriquées les unes dans les autres. Cependant, il restait à résoudre un problème : comment transformer une liste contenant ««"2+3"»» en une liste contenant ««"ad(td(2),td(3))"»» ?

Pour y parvenir, j’ai créé plusieurs fonctions préfixées par ««manage...»» :
««manageConstant(...)»», ««manageNumber(...)»», ««manageOperator(...)»»,
««manageExternalFunction(...)»» et ««manageAdditionalParentheses(...)»».

Ces fonctions permettent de convertir une liste issue de la saisie utilisateur en une liste utilisant les fonctions internes, et dont le contenu correspond aux attentes de la fonction ««operate(...)»». L’ordre d’appel de ces fonctions est défini directement dans le code et permet une transformation progressive et cohérente de la saisie utilisateur.


SECTION 5 : TRANSFORMATION D’UNE OPÉRATION SAISIE PAR L’UTILISATEUR

À ce stade, je sais hiérarchiser les opérations et traiter les opérateurs, mais il restait à déterminer l’ordre dans lequel les opérateurs d’un même bloc doivent être évalués. Pour cela, j’ai créé la fonction ««sortOperators(...)»», qui permet de trier une liste d’opérateurs selon leur priorité.

J’ai ensuite créé la fonction ««manageBlockOperators(...)»», chargée de trier et de traiter tous les opérateurs d’un bloc d’opérations. Enfin, la fonction ««manageAllObjects(...)»» permet de traiter l’ensemble des éléments constituant une opération.

Désormais, lorsqu’une opération est correctement formulée par l’utilisateur, elle peut être convertie en une chaîne de caractères valide, prête à être transmise à la fonction ««operate(...)»». Cependant, toutes les saisies utilisateur ne sont pas nécessairement correctes. Il est donc nécessaire de vérifier la validité syntaxique des opérations avant toute tentative d’évaluation, afin d’éviter des comportements indéfinis ou des résultats incohérents.


SECTION 6 : VALIDATION DE LA SYNTAXE DES OPÉRATIONS

Afin de valider la syntaxe des opérations saisies par l’utilisateur, j’ai d’abord créé la fonction ««stringToList(...)»», qui permet de convertir une chaîne de caractères en liste. Cette fonction analyse la chaîne et identifie les objets d’opération qui la composent, puis les regroupe sous forme de liste.

Par la suite, j’ai créé diverses fonctions permettant d’analyser la syntaxe d’une opération. Pour mieux comprendre les règles appliquées, il est recommandé de lire le fichier «Les règles syntaxiques.txt», qui détaille les contraintes syntaxiques.

J’ai également ajouté les fonctions ««manageAllConstants(...)»» et ««manageImplicitMultiplications(...)»», qui permettent de gérer certains détails avant que la liste ne soit utilisée dans le reste du programme. À ce stade, le programme est capable d’effectuer les calculs demandés.


SECTION 7 : INTERFACE EN LIGNE DE COMMANDE ET OUTILS SUPPLÉMENTAIRES

Afin de rendre le programme facile à utiliser, j’ai créé plusieurs fonctions supplémentaires, telles que ««isCommand(...)»» ou ««c_setPrecision(...)»», et j’ai écrit le code nécessaire pour fournir une interface utilisateur en ligne de commande.

À cette étape, j’ai également réfléchi à la possibilité d’étendre la calculatrice avec des outils supplémentaires. Pour le moment, un seul outil a été ajouté : il permet de vérifier si un nombre est premier ou non. L’architecture du programme permet toutefois d’ajouter d’autres outils ultérieurement sans modifier le cœur du moteur de calcul.

